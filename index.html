<!doctype html>
<html lang="sq">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>NINXHA W211 â€” 3D Lite (mobile-friendly)</title>
<style>
  html,body { height:100%; margin:0; background:#0b1020; color:#fff; font-family:Arial, sans-serif; -webkit-user-select:none; user-select:none; touch-action:none; }
  #container { width:100%; height:100%; position:relative; overflow:hidden; }
  #hud {
    position:absolute; left:12px; top:12px; z-index:20;
    display:flex; gap:10px; flex-direction:column;
  }
  .panel {
    background:rgba(0,0,0,0.5); padding:10px 14px; border-radius:10px; border:1px solid rgba(255,255,255,0.06);
    backdrop-filter: blur(4px);
  }
  #score { font-size:16px; }
  #healthBar { width:200px; height:12px; background:#222; border-radius:8px; overflow:hidden; margin-top:6px; }
  #healthFill { height:100%; background:linear-gradient(90deg,#ff4d4d,#ffb86b); width:100%; }
  /* Controls bottom */
  #controls {
    position:absolute; bottom:18px; left:0; right:0; z-index:20; display:flex; justify-content:space-between; padding:0 18px; pointer-events:none;
  }
  /* Joystick area */
  #leftControl { width:40%; max-width:320px; height:180px; pointer-events:auto; }
  #rightControl { width:40%; max-width:320px; height:180px; pointer-events:auto; display:flex; justify-content:flex-end; gap:12px; align-items:center; }
  .stick {
    width:120px; height:120px; border-radius:50%; background:rgba(255,255,255,0.06); position:relative;
    touch-action:none;
  }
  .thumb {
    width:56px; height:56px; border-radius:50%; background:rgba(255,255,255,0.18); position:absolute; left:50%; top:50%; transform:translate(-50%,-50%); display:flex; align-items:center; justify-content:center;
  }
  .btn {
    width:72px; height:72px; border-radius:12px; background:linear-gradient(180deg,#6f00ff,#3a00a1); display:flex; align-items:center; justify-content:center; font-size:18px; pointer-events:auto; box-shadow:0 6px 18px rgba(0,0,0,0.6);
  }
  .small { width:56px; height:56px; border-radius:10px; font-size:14px; }
  #msg { position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); z-index:25; font-size:20px; background:rgba(0,0,0,0.6); padding:12px 18px; border-radius:8px; display:none; }
  /* responsive */
  @media(min-width:900px){
    #leftControl, #rightControl { height:220px; }
    .stick { width:150px; height:150px; }
    .thumb { width:70px; height:70px; }
  }
</style>
</head>
<body>
<div id="container"></div>

<!-- HUD -->
<div id="hud">
  <div class="panel">
    <div id="score">PikÃ«: <span id="scoreVal">0</span></div>
    <div id="healthBar"><div id="healthFill"></div></div>
    <div style="margin-top:8px; font-size:13px;">Nivel: <span id="levelVal">1</span> &nbsp; Gems: <span id="gemsVal">0</span></div>
  </div>
  <div class="panel" id="savePanel">
    <div style="font-size:13px;">Ruajtje automatike: <span id="saveStatus">OK</span></div>
  </div>
</div>

<!-- Controls -->
<div id="controls">
  <div id="leftControl">
    <div id="stick" class="stick" aria-hidden="true">
      <div id="thumb" class="thumb">â—‰</div>
    </div>
  </div>
  <div id="rightControl">
    <div id="btnAttack" class="btn small">Sulm</div>
    <div id="btnDash" class="btn small">Dash</div>
    <div id="btnAd" class="btn small">ðŸŽ¬ Ad</div>
  </div>
</div>

<div id="msg">Ready</div>

<!-- Three.js from CDN (r152 as example). Mund ta ndryshosh nÃ« version tÃ« fundit kur publikosh. -->
<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
<script>
/*
  NINXHA W211 â€” Lite 3D
  Funksionalitet i plotÃ« baze: lÃ«vizje 3D, armik, kollizion, scoring, pool, storage, simulated ad.
  Dizajnuar pÃ«r performancÃ« mobile: low-poly, pooling, kufizime obj.
*/

/* ---------------------- SETTINGS ---------------------- */
const SETTINGS = {
  enemyMax: 12,
  spawnInterval: 1400,
  enemySpeed: 0.6,
  playerSpeed: 6.0,
  dashMultiplier: 2.6,
  canvasPixelRatioMax: 1.5,
  adWatchSeconds: 5
};

/* ---------------------- STATE ---------------------- */
let state = {
  score: 0,
  gems: 0,
  level: 1,
  health: 100,
  maxHealth: 100,
  lastSpawn: 0,
  enemiesActive: 0,
  running: true
};

/* ---------------------- STORAGE ---------------------- */
const STORAGE_KEY = 'ninxha_w211_save_v1';
function loadSave(){
  try{
    const raw = localStorage.getItem(STORAGE_KEY);
    if(raw){
      const s = JSON.parse(raw);
      state.score = s.score||0;
      state.gems = s.gems||0;
      state.level = s.level||1;
      state.health = s.health || state.maxHealth;
      updateHUD();
    }
  }catch(e){ console.warn('load err',e); }
}
function saveProgress(){
  try{
    const to = { score: state.score, gems: state.gems, level: state.level, health: state.health };
    localStorage.setItem(STORAGE_KEY, JSON.stringify(to));
    document.getElementById('saveStatus').textContent = 'OK';
  }catch(e){
    document.getElementById('saveStatus').textContent = 'ERR';
  }
}

/* ---------------------- THREE.JS SETUP ---------------------- */
const container = document.getElementById('container');
const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x0a0a12, 0.0025);

const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:false });
renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, SETTINGS.canvasPixelRatioMax));
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
container.appendChild(renderer.domElement);

const camera = new THREE.PerspectiveCamera(55, window.innerWidth/window.innerHeight, 0.1, 5000);
camera.position.set(0, 8, 18);

/* LIGHTS */
const dirLight = new THREE.DirectionalLight(0xffffff, 0.9);
dirLight.position.set(5, 20, 10);
dirLight.castShadow = true;
scene.add(dirLight);

const amb = new THREE.AmbientLight(0x9090b0, 0.6);
scene.add(amb);

/* GROUND */
const groundGeo = new THREE.PlaneGeometry(200,200);
const groundMat = new THREE.MeshStandardMaterial({ color:0x08102a, roughness:0.9, metalness:0.1 });
const ground = new THREE.Mesh(groundGeo, groundMat);
ground.rotation.x = -Math.PI/2;
ground.receiveShadow = true;
scene.add(ground);

/* ---------------------- PLAYER (simple low-poly ninja) ---------------------- */
const player = new THREE.Group();
player.position.set(0, 1.2, 0);
player.castShadow = true;

// body
const bodyMat = new THREE.MeshStandardMaterial({ color:0x101020, roughness:0.6, metalness:0.2 });
const body = new THREE.Mesh(new THREE.CapsuleGeometry(0.8, 1.2, 4, 8), bodyMat);
body.castShadow = true;
player.add(body);

// head (hood)
const head = new THREE.Mesh(new THREE.SphereGeometry(0.55, 12, 9), new THREE.MeshStandardMaterial({ color:0x151531 }));
head.position.set(0,1.2,0);
head.castShadow = true;
player.add(head);

// eyes (glow)
const eyeMat = new THREE.MeshBasicMaterial({ color:0x00ffd6 });
const eyeL = new THREE.Mesh(new THREE.BoxGeometry(0.18,0.06,0.02), eyeMat);
const eyeR = eyeL.clone();
eyeL.position.set(-0.18,1.15,0.52); eyeR.position.set(0.18,1.15,0.52);
player.add(eyeL); player.add(eyeR);

scene.add(player);

/* weapon (visual) */
const blade = new THREE.Mesh(new THREE.BoxGeometry(0.08,0.9,0.02), new THREE.MeshStandardMaterial({ color:0xffd166 }));
blade.position.set(0.9,0.2,0);
blade.rotation.z = -0.5;
player.add(blade);

/* PLAYER PHYSICS */
let playerVel = new THREE.Vector3(0,0,0);
let input = { x:0, z:0, attack:false, dash:false };

/* ---------------------- ENEMY POOL (object pooling) ---------------------- */
const enemyPool = [];
const activeEnemies = [];

const enemyGeom = new THREE.CylinderGeometry(0.6,0.6,1.4,10);
const enemyMat = new THREE.MeshStandardMaterial({ color:0x7b1fa2, roughness:0.7 });

function createEnemy(){
  const g = new THREE.Mesh(enemyGeom, enemyMat);
  g.castShadow = true;
  g.position.set(20, 0.7, (Math.random()-0.5)*60);
  g.health = 20 + Math.floor(Math.random()*30);
  g.speed = 0.4 + Math.random()*0.6;
  g._alive = false;
  scene.add(g);
  enemyPool.push(g);
}
for(let i=0;i<SETTINGS.enemyMax;i++) createEnemy();

function spawnEnemy(){
  if(enemyPool.length===0) return;
  const e = enemyPool.pop();
  e.position.set( (Math.random()<0.5?-1:1)*(12 + Math.random()*8), 0.7, (Math.random()-0.5)*24 );
  e.health = 18 + Math.floor(Math.random()*40);
  e._alive = true;
  activeEnemies.push(e);
  state.enemiesActive = activeEnemies.length;
}

/* ---------------------- SIMPLE BULLET POOL ---------------------- */
const bulletPool = [];
const activeBullets = [];
const bulletGeom = new THREE.SphereGeometry(0.12,8,6);
const bulletMat = new THREE.MeshStandardMaterial({ color:0xfff2c2, emissive:0xffd166, emissiveIntensity:0.6 });

for(let i=0;i<24;i++){
  const b = new THREE.Mesh(bulletGeom, bulletMat);
  b.visible = false; scene.add(b);
  bulletPool.push(b);
}

function fireBullet(origin, dir){
  if(bulletPool.length===0) return;
  const b = bulletPool.pop();
  b.position.copy(origin);
  b.userData = { dir: dir.clone(), life: 120 };
  b.visible = true;
  activeBullets.push(b);
}

/* ---------------------- COLLISION helpers ---------------------- */
function dist2(a,b){ return a.distanceToSquared(b); }

/* ---------------------- CAMERA follow ---------------------- */
const camOffset = new THREE.Vector3(0,6,14);

/* ---------------------- HUD helpers ---------------------- */
function updateHUD(){
  document.getElementById('scoreVal').textContent = Math.floor(state.score);
  document.getElementById('gemsVal').textContent = state.gems;
  document.getElementById('levelVal').textContent = state.level;
  const percent = Math.max(0, Math.min(1, state.health / state.maxHealth));
  document.getElementById('healthFill').style.width = (percent*100) + '%';
}

/* ---------------------- INPUT (virtual joystick) ---------------------- */
const stick = document.getElementById('stick');
const thumb = document.getElementById('thumb');
let stickActive = false;
let stickRect = null;
let stickCenter = { x:0, y:0 };

function updateStickPosition(clientX, clientY){
  if(!stickRect) stickRect = stick.getBoundingClientRect();
  const x = clientX - (stickRect.left + stickRect.width/2);
  const y = clientY - (stickRect.top + stickRect.height/2);
  const max = stickRect.width/2 - 10;
  const nx = Math.max(-max, Math.min(max, x));
  const ny = Math.max(-max, Math.min(max, y));
  thumb.style.transform = `translate(${nx}px, ${ny}px)`;
  input.x = nx / max;
  input.z = ny / max * -1; // invert so up moves forward (negative Z)
}

function resetThumb(){
  thumb.style.transform = `translate(-50%,-50%)`;
  input.x = 0; input.z = 0;
}

stick.addEventListener('touchstart', (e)=>{
  e.preventDefault();
  stickActive = true;
  updateStickPosition(e.touches[0].clientX, e.touches[0].clientY);
});
stick.addEventListener('touchmove', (e)=>{
  e.preventDefault();
  updateStickPosition(e.touches[0].clientX, e.touches[0].clientY);
});
stick.addEventListener('touchend', (e)=>{
  e.preventDefault();
  stickActive = false;
  resetThumb();
});
/* also support mouse for desktop testing */
stick.addEventListener('mousedown', (e)=>{
  e.preventDefault(); stickActive = true; updateStickPosition(e.clientX, e.clientY);
});
window.addEventListener('mousemove', (e)=>{ if(stickActive) updateStickPosition(e.clientX, e.clientY); });
window.addEventListener('mouseup', ()=>{ if(stickActive){ stickActive=false; resetThumb(); } });

/* Buttons */
document.getElementById('btnAttack').addEventListener('touchstart', (e)=>{ e.preventDefault(); input.attack = true; });
document.getElementById('btnAttack').addEventListener('touchend', (e)=>{ e.preventDefault(); input.attack = false; });
document.getElementById('btnDash').addEventListener('touchstart', (e)=>{ e.preventDefault(); input.dash = true; setTimeout(()=>{ input.dash=false; }, 200); });
document.getElementById('btnAd').addEventListener('touchstart', (e)=>{ e.preventDefault(); simulateAd(); });

/* desktop clicks */
document.getElementById('btnAttack').addEventListener('mousedown', ()=>{ input.attack=true; });
document.getElementById('btnAttack').addEventListener('mouseup', ()=>{ input.attack=false; });
document.getElementById('btnDash').addEventListener('click', ()=>{ input.dash=true; setTimeout(()=>input.dash=false,220); });
document.getElementById('btnAd').addEventListener('click', ()=>simulateAd());

/* ---------------------- GAME LOGIC ---------------------- */
let lastTime = performance.now();

function update(dt){
  // movement
  const speed = SETTINGS.playerSpeed * (input.dash ? SETTINGS.dashMultiplier : 1);
  const forward = new THREE.Vector3(input.x, 0, input.z).normalize().multiplyScalar(speed * dt * 0.06);
  player.position.x += forward.x;
  player.position.z += forward.z;
  // clamp area
  player.position.x = Math.max(-28, Math.min(28, player.position.x));
  player.position.z = Math.max(-28, Math.min(28, player.position.z));

  // simple rotation to move direction
  if(Math.abs(input.x) + Math.abs(input.z) > 0.02){
    const ang = Math.atan2(input.x, input.z);
    player.rotation.y = ang;
  }

  // camera follow (lerp)
  const desiredCam = player.position.clone().add(camOffset);
  camera.position.lerp(desiredCam, 0.08);
  camera.lookAt(player.position.x, player.position.y+1.2, player.position.z);

  // spawn enemies
  if(performance.now() - state.lastSpawn > SETTINGS.spawnInterval && activeEnemies.length < SETTINGS.enemyMax){
    spawnEnemy();
    state.lastSpawn = performance.now();
  }

  // update enemies
  for(let i=activeEnemies.length-1;i>=0;i--){
    const e = activeEnemies[i];
    if(!e._alive) continue;
    // move towards player
    const dir = player.position.clone().sub(e.position);
    dir.y = 0;
    dir.normalize();
    e.position.addScaledVector(dir, e.speed * dt * 0.06);

    // if close -> damage player
    if(dist2(e.position, player.position) < 1.1){
      // damage and knockback
      if(performance.now() % 400 > 200){ /* reduce rate */ }
      state.health -= 0.3 * dt;
      if(state.health <= 0){
        state.running = false;
        showMessage('Humbe! Rifresko faqen pÃ«r tÃ« provuar pÃ«rsÃ«ri.');
      }
    }

    // check bullets hitting enemy
    for(let bI=activeBullets.length-1;bI>=0;bI--){
      const b = activeBullets[bI];
      if(!b.visible) continue;
      if(dist2(b.position, e.position) < 0.9){
        e.health -= 15;
        // bullet expire
        b.userData.life = 0;
        state.score += 6;
        updateHUD();
      }
    }

    if(e.health <= 0){
      // kill -> reward
      state.score += 20 + Math.floor(Math.random()*20);
      if(Math.random() < 0.12){ state.gems += 1; }
      // remove enemy
      e._alive = false;
      // return to pool
      activeEnemies.splice(i,1);
      enemyPool.push(e);
      state.enemiesActive = activeEnemies.length;
      updateHUD();
    }
  }

  // bullets update
  for(let i=activeBullets.length-1;i>=0;i--){
    const b = activeBullets[i];
    if(!b.visible) { activeBullets.splice(i,1); continue; }
    b.position.addScaledVector(b.userData.dir, dt*0.18);
    b.userData.life -= dt;
    if(b.userData.life <= 0 || Math.abs(b.position.x)>120 || Math.abs(b.position.z)>120){
      b.visible = false;
      bulletPool.push(b);
      activeBullets.splice(i,1);
    }
  }

  // if attack => fire a bullet (rate limit)
  if(input.attack && performance.now() - (player.userData?.lastShot||0) > 220){
    const dir = new THREE.Vector3(0,0,1).applyQuaternion(player.quaternion).normalize();
    const origin = player.position.clone().add(new THREE.Vector3(0,1.0,0).add(dir.clone().multiplyScalar(1.2)));
    fireBullet(origin, dir);
    player.userData = player.userData || {};
    player.userData.lastShot = performance.now();
  }

  // CPU-friendly: cap score growth for level up
  if(state.score >= state.level * 500){
    state.level++;
    state.maxHealth += 10;
    state.health = state.maxHealth;
    showMessage('Nivel i ri! ' + state.level);
    updateHUD();
  }

  // passive regen small
  state.health = Math.min(state.maxHealth, state.health + 0.02*dt);

  updateHUD();
}

/* ---------------------- RENDER LOOP ---------------------- */
function animate(){
  const now = performance.now();
  const dt = Math.min(40, now - lastTime); // clamp dt
  if(state.running) update(dt);
  renderer.render(scene, camera);
  lastTime = now;
  requestAnimationFrame(animate);
}
animate();

/* ---------------------- UTIL: message ---------------------- */
const msgEl = document.getElementById('msg');
let msgTimer = null;
function showMessage(text, dur=1600){
  msgEl.style.display = 'block';
  msgEl.textContent = text;
  if(msgTimer) clearTimeout(msgTimer);
  msgTimer = setTimeout(()=>{ msgEl.style.display = 'none'; }, dur);
}

/* ---------------------- Simulated Ad (timer-based, honest) ---------------------- */
let adInProgress = false;
function simulateAd(){
  if(adInProgress) return;
  adInProgress = true;
  showMessage('Shiko reklamÃ«n pÃ«r ' + SETTINGS.adWatchSeconds + 's...');
  // show a simple on-screen countdown
  const start = performance.now();
  const tick = ()=>{
    const elapsed = Math.floor((performance.now()-start)/1000);
    const left = SETTINGS.adWatchSeconds - elapsed;
    if(left <= 0){
      adInProgress = false;
      // reward
      state.gems += 3;
      state.score += 120;
      saveProgress();
      updateHUD();
      showMessage('ShpÃ«rblim marrÃ«: +3 Gems +120 PikÃ«',2200);
      return;
    }else{
      msgEl.textContent = 'Shiko reklamÃ«n pÃ«r ' + left + 's...';
      setTimeout(tick, 500);
    }
  };
  tick();
}

/* ---------------------- EVENT: resize ---------------------- */
window.addEventListener('resize', ()=>{
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

/* ---------------------- Autosave ---------------------- */
setInterval(saveProgress, 6000);

/* ---------------------- INITIALIZE ---------------------- */
loadSave();
updateHUD();
showMessage('NINXHA W211 â€” 3D Lite', 1200);

/* ---------------------- Performance note: spawn loop by timer ---------------------- */
setInterval(()=>{ if(state.running) spawnEnemy(); }, SETTINGS.spawnInterval);

/* ---------------------- debug helper (desktop) ---------------------- */
window._state = state;
window._scene = scene;

</script>
</body>
</html>
